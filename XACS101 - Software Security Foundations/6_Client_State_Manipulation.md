# Client-State Manipulation

---

**Never trust the client.**

**Web application**: collection of programs used by server to reply to client (browser) requests
- don't trust : validate!

**HTTP is stateless; servers don't keep state!**
- web app needs state for transactions
- state info may be sent to client who echoes it back to future requests

**Hidden parameters is HTML are not really hidden and can be manipulated**

### Don't try this at home (ie. on production servers IRL)

## 7.1 Pizza Delivery Web Site Example

- web app for delivering pizza
  - confirmation form generated by `confirm_order` script asking to verify purchase
  - price sent as a hidden field
- once action taken on confirmation form, request is taken to `submit_order` script to actually submit the order

### Pizza Website Code
- confirmation form is a simple html page with a form
- if the user presses `yes`, submit order script receives the prices along with the variable `pay` with a value of `yes` or `no`
- there's a simple program on the server that says if user hit `yes`, access credit card, pass price from the form and if credit card successfully charged then the transaction should be settled and dispatch the delivery person

## 7.1.1 Attack Scenario

**Can the attacker modify the price?**

If they do modify the price, what happens?
- attacker can view the html source
- attacker can save html to local disk, and with a copy of the form saved they can change the value of the form item `price`
- can reload the file on disk that the attacker just modified 
- the submit order script will receive the same values with only the price changed

**tldr; hidden variables aren't actually really hidden**

### Has this actually happened?
- in the late 90s, developers hadn't thought of this particular vector 
- kids changed the price of their order to something negative, and the credit card was refunded for the amount
- products were still shipped to them

**You should never take authoritative state -- never give important information to the client and trust it.**

- these attacks can basically be done through `wget` and `cURL` rather than reloading the browser

## 7.1.2 Solution 1: Authoritative State Stays on Server
- never let authoritative state leave the server

**How do I keep track of prices for everyone's orders?**
- for each client that comes to you, send that client a `session ID`
  - might be some random 128-bit number
  - when client comes to you, and when they build up their order, you keep things like the contents of their shopping card and price actually on the server in a DB server indexed by the session ID
  - instead of putting the _price_ of the transaction in the form, you put the `sessionID` instead
- when the server gets the request with the `sessionID`, will query the db for the price of the transaction

### Session Management
- attacker may need to forge a sessionID
- predicting what the user session ID is becomes really important
- chance of a correct guess is n/2^128...so that's pretty tricky

**All kinds of websites use session IDs, and if you can predict a `sessionID`, you can take over**
- if an attacker can somehow predict how the server is giving out session IDs, they can mimic the server and start issuing trades
- typical sequence of events is:
  - user comes to web page
  - asked to login and provide username/password
  - authenticates and if valid, gives client a session ID
  - every future interaction will be based on that session ID
- if a user is logged in for longer than some time period, you should time out the session IDs
  - if longer than, say, 20 min throw out all state associated with the sessionID
  - otherwise gives attackers open window for trying to brute-force session IDs
  - session ID expiry will depend on the type of application

### Expiramental Session IDs
- mashing up sessionIDs with a user's IP address
- fragile, but harder to attack
- usually you want to use some library or application server framework that already does this for you
- it can be _really_ easy to get it wrong, so rely on some well-vetted application server infrastructure

### Performance Issues
- if you're not handing off state to teh client and you have to rely on the server it can create a bottleneck
- every time a user logs in, looking up sessionID in DB
  - use load balancing for requests to prevent performance issues
- most services parallelize or shard their databases so look-up requests can be balanced

## 7.1.3 Solution 2: Signed State to Client

- give all the state back to the client (prices of the transactions, for example) but give the data in such a way that it can't be tampered with
- keeping the server stateless, and in the form that contains the price of the transaction, we're going to include a "signature"
  - signature is basically a message authentication code
  - construct it based on the entire state of the transaction
    - ex. item IDs associated with the order, credit card number, other state items
  - take all state -- together with secret key from server -- merge all data and create a secret signature that you also put in the form
- if an attacker wanted to modify the price or any other parameters, then because the attacker doesn't know what the secret key is, they couldn't recompute a proper signature
- if the transaction state arrives at the server, the server would drop the request if the signature didn't match 

### How do We Do This?
- if user confirms, aggregate together all the state including the price
- compute a message authentication code based on this transction + secret code _only_ known to server
- if signature parameter passed matches signature from the form computed by the server previously, proceed normally 
- otherwise signature's invalid and you can cancel and log the transaction

### Performance Cost
- very very lightweight computations compared to other server transactions
- but extra bandwidth for sending data between client-server
- previously, sessionID went back and forth and that was it; look-up cost with database
- in this case, no database look-up cost, but there is extra bandwith and some simple computations that need to be done on the server

## 7.2 Information Leakage

- `GET` form params leak information in the URL
- sessionID can appear in weblogs when passed off to 3rd party sites
- client may be going through a proxy, and session IDs can end up in proxy logs as well which could make them a target for attack
- referrers can also leak (not just through clicking) but also through images

### Benefits of `POST`
- instead of putting parameters inside URLs, puts them inside the body of the request
- data is put in body of HTTP request rather than header or URL -- prevents this kind of information leakage
- people often even just email URLs to each other, and you really wouldn't want a session ID to be within the url
  - ex. sharing a link to an email with a sessionID in the url could allow the recipient to take control of your entire session

## 7.3 Cookies

**Cookie**: piece of state maintained by a _client_
- server gives cookie to client
- client returns cookie to server in HTTP requests
- sessionID needs to be carried over from one page request to another, and doing a form submission and POST for every single request would be stupid; cookies solve this
- whenever client returns to that server (ex. Twitter.com), the user's browser should give back the same cookie as part of the HTTP request
  - ex. Twitter.com gives the user a cookie; even if user leaves the next time they revisit Twitter.com, they're given back the same cookie
- can help with session management and state management
- if you would like the sessionID or cookie info to be sent only over SSL, the server can mark the cookie as secure (which basically just says that SSL should be used)

**Benefit**: server doesn't need to include state information into every form or interaction.     

- clients are trusted with cookie information, but that's all they're trusted with
  - and it shouldn't be information you don't want visible 
  - ex. don't put the price of a transaction in the cookie...bad news

### Problems with Cookies
- if user doesn't log out, attacker can use the same browser to impersonate the user
  - ex. with public computers
- sessionIDs should have limited lifetimes

## 7.4 JavaScript

- popular client-side scripting language
- programmer may want to reduce load on server and allow user to have faster interactions
  - therefore, could compute price of transaction on the client
  - everytime user changes number of items to purchase, could automatically compute and display an updated price
  - updates price field to new price
- from a security perspective, key is that the price is still being generated on the client
  - malicious client doesn't _need_ to use your existing js to compute the price
- even if some things are good for UI and reducing latency, whatever params are sent off to the server the computation has to be redone on the _server_
  - **You can't trust the client!!!!**
- attacker could submit a request bypassing the javascript that was originally shipped with the site

### AJAX (Asynchronous Java and XML)
- since mid 2000s (arrival of AJAX), have been more computations happening on clients
- you can't trust it -- even with AJAX frameworks
 
